from shapes import *
from structure import *

# cpos=center.pos, pos, s=scale, c1=color.component1, c2=color.component2, c3=color.component3
def back_cylinder(cpos, pos, s, r, c1,c2,c3, radius):
        fill (c1, c2, c3)
        pushMatrix()
        translate (pos[0] + cpos[0], pos[1] + cpos[1], pos[2] + cpos[2])
        rotateX (r)
        scale (s, s, s * 1.3)
        d_cylinder(radius)
        popMatrix()
        
        fill (c1, c2, c3)
        pushMatrix()
        translate (cpos[0]-pos[0], cpos[1]-pos[1], cpos[2]-pos[2])
        rotateX (r)
        scale (s, s, s * 1.3)
        d_cylinder(radius)
        popMatrix()

def eng_cylinder_with_arm(time):
        x, y, z = eng_cylinder1(1, time)
        radius = 1 

        pushMatrix()
        c_z = 0.3
        translate(x, y, (z) + c_z + 0.2)
        bearing(radius)
        popMatrix()

        pushMatrix()
        translate(x, y, z + 0.4 + 0.2)
        rotateX(abs(sin(radians(time * 20))))
        x_a, y_a, z_top, z_bottom = armStructure(radius, x, y, z, 0.2, time)
        translate(x_a, y_a, z_bottom)
        x_b, y_b = bearing(radius)

        popMatrix()
        

def wing_position(x,y,z, time, s_angle):
        # Left-Below 
        translate(x,y,0)
        tur_x, tur_y, tur_z = turbine(1,1)
        rotateZ(radians(30))
        shearX(s_angle)
        wing_ed_x, wing_ed_y, wing_ed_z = wings(tur_x, 0, 0, 5, time)
        shearX(-s_angle)
        wing_edge(wing_ed_x, wing_ed_y, wing_ed_z)
        rotateZ(radians(-30))
        translate(-x,-y,0)
        
        # Right-Below 
        translate(-x,y,0)
        tur_x, tur_y, tur_z = turbine(1,1)
        rotateZ(radians(-210))
        shearX(-s_angle)
        wing_ed_x, wing_ed_y, wing_ed_z = wings(tur_x, 0, 0, 5, time)
        shearX(s_angle)
        wing_edge(wing_ed_x, wing_ed_y, wing_ed_z)
        rotateZ(radians(210))
        translate(x,-y,0)
        
        # Upper-Left
        translate(x,-y,0)
        tur_x, tur_y, tur_z = turbine(1,1)
        rotate(radians(-30))
        shearX(-(s_angle+radians(180)))
        wing_ed_x, wing_ed_y, wing_ed_z = wings(tur_x, 0, 0, 5, time)
        shearX(s_angle+radians(180))
        wing_edge(wing_ed_x, wing_ed_y, wing_ed_z)
        rotate(radians(30))
        translate(-x,y,0)
        
        # Upper-Right
        translate(-x,-y,0)
        tur_x, tur_y, tur_z = turbine(1,1)
        rotate(radians((30+180)))
        shearX((s_angle+radians(180)))
        wing_ed_x, wing_ed_y, wing_ed_z = wings(tur_x, 0, 0, 5, time)
        shearX(-(s_angle+radians(180)))
        wing_edge(wing_ed_x, wing_ed_y, wing_ed_z)
        rotate(radians(-(30+180)))
        translate(x,y,0)

        ship_body(0,0,0, time)


# Object Modeling Example Code
# Seonghyun Lee
# GT ID: 903452500

from __future__ import division
import traceback
from shapes import *
from positions import *
from structure import *  

time = 0   # time is used to move objects from one frame to another
angle = 0

def setup():
    size (950, 950, P3D)
    try:
        frameRate(120)       # this seems to be needed to make sure the scene draws properly
        perspective (60 * PI / 180, 1, 0.1, 1000)  # 60-degree field of view
    except Exception:
        traceback.print_exc()

def draw():
    try:
        global time, angle
        time += 0.01

        camera (0, 0, 100, 0, 0, 0, 0,  1, 0)  # position of the virtual camera

        background (50, 50, 50)  # clear screen and set background to light blue
        
        # Set up the lights
        ambientLight(50, 50, 50);
        lightSpecular(255, 255, 255)
        directionalLight (100, 100, 100, 0.3, 0.5, -1)
        
        # Set some of the surface properties
        noStroke()
        specular (180, 180, 180)
        shininess (15.0)

        # # a blue cylinder
        # fill (200, 200, 200)
        # pushMatrix()
        # translate (0, -35, 0)
        # if mousePressed:
        #     angle += 0.5
        #     rotateY(radians(angle))
        # rotateX(radians(5))
        # rotateY(radians(20))
        # scale (5, 5, 5)
        # #eng_cylinder_with_arm(time)
        # #turbine(1,1)
        # popMatrix()
        
        fill (200, 200, 200)
        pushMatrix()
        translate (4.6, -5, -5)

        angle += 0.75
        rotateY(radians(angle))
        s_val = 2
        rotateX(radians(-25))
        rotateY(radians(-165))
        scale (s_val, s_val, s_val)
        s_angle = radians(30)
        
        wing_position(5,2.5,0,time,s_angle)
        # translate(5,0,0)
        # tur_x, tur_y, tur_z = turbine(1,1)
        # rotateZ(radians(30))
        # shearX(s_angle)
        # wing_ed_x, wing_ed_y, wing_ed_z = wings(tur_x, 0, 0, 5, time)
        # shearX(-s_angle)
        # wing_edge(wing_ed_x, wing_ed_y, wing_ed_z)
        # rotateZ(radians(-30))
        # translate(-5,0,0)
        
        # translate(-5,0,0)
        # tur_x, tur_y, tur_z = turbine(1,1)
        # rotateZ(radians(-210))
        # shearX(-s_angle)
        # wing_ed_x, wing_ed_y, wing_ed_z = wings(tur_x, 0, 0, 5, time)
        # shearX(s_angle)
        # wing_edge(wing_ed_x, wing_ed_y, wing_ed_z)
        # rotateZ(radians(210))
        # translate(5,0,0)
        
        # translate(5,-5,0)
        # tur_x, tur_y, tur_z = turbine(1,1)
        # rotate(radians(-30))
        # shearX(-(s_angle+radians(180)))
        # wing_ed_x, wing_ed_y, wing_ed_z = wings(tur_x, 0, 0, 5, time)
        # shearX(s_angle+radians(180))
        # wing_edge(wing_ed_x, wing_ed_y, wing_ed_z)
        # rotate(radians(30))
        # translate(-5,5,0)
        
        # translate(-5,-5,0)
        # tur_x, tur_y, tur_z = turbine(1,1)
        # rotate(radians((30+180)))
        # shearX((s_angle+radians(180)))
        # wing_ed_x, wing_ed_y, wing_ed_z = wings(tur_x, 0, 0, 5, time)
        # wing_edge(wing_ed_x, wing_ed_y, wing_ed_z)
        # shearX(-(s_angle+radians(180)))
        # rotate(radians(-(30+180)))
        # translate(5,5,0)
   
        
        popMatrix()

        # fill(0,100,100)
        # pushMatrix()
        # translate(30, 0, 0)
        # rotateX(60 * time * 0.05)
        # scale(10, 10, 10)
        # torus()
        # popMatrix()

    except Exception:
        traceback.print_exc()

# Object Modeling Example Code
# Seonghyun Lee
# GT ID: 903452500

from __future__ import division
import traceback
from shapes import *
from positions import *
from engineParts import *  

time = 0   # time is used to move objects from one frame to another
angle = 0

def setup():
    size (950, 950, P3D)
    try:
        frameRate(60)       # this seems to be needed to make sure the scene draws properly
        perspective (60 * PI / 180, 1, 0.1, 1000)  # 60-degree field of view
    except Exception:
        traceback.print_exc()

def draw():
    try:
        global time, angle
        time += 0.01

        camera (0, 0, 100, 0, 0, 0, 0,  1, 0)  # position of the virtual camera

        background (50, 50, 50)  # clear screen and set background to light blue
        
        # Set up the lights
        ambientLight(50, 50, 50);
        lightSpecular(255, 255, 255)
        directionalLight (100, 100, 100, -0.3, 0.5, -1)
        
        # Set some of the surface properties
        noStroke()
        specular (180, 180, 180)
        shininess (15.0)

        # # a blue cylinder
        # fill (200, 200, 200)
        # pushMatrix()
        # translate (0, -35, 0)
        # if mousePressed:
        #     angle += 0.5
        #     rotateY(radians(angle))
        # rotateX(radians(5))
        # rotateY(radians(20))
        # scale (5, 5, 5)
        # #eng_cylinder_with_arm(time)
        # #turbine(1,1)
        # popMatrix()
        
        fill (200, 200, 200)
        pushMatrix()
        translate (0, 0, -5)
        if mousePressed:
            angle += 0.5
            rotateY(radians(angle))
        s_val = 2
        rotateX(radians(10))
        rotateY(radians(-135))
        scale (s_val, s_val, s_val)
        s_angle = radians(30)
        
        wing_position(5,5,0,time,s_angle)
        
        popMatrix()

        # fill(0,100,100)
        # pushMatrix()
        # translate(30, 0, 0)
        # rotateX(60 * time * 0.05)
        # scale(10, 10, 10)
        # torus()
        # popMatrix()

    except Exception:
        traceback.print_exc()

# Cylinder with radius = 1, z range in [-1,1]

def cylinder(radius, sides = 20):
    # first endcap
    v = []
    seg = []
    for i in range(sides):
        v1 = []
        theta = i * 2 * PI / sides
        x = cos(theta) * radius 
        y = sin(theta) * radius
        seg.append([x, y, -1])
    v.append(seg)
    
    #second endcap
    seg = []
    for i in range(sides):
        theta = i * 2 * PI / sides
        x = cos(theta) * radius
        y = sin(theta) * radius
        seg.append([x, y, 1])
    v.append(seg)
    
    # round main body
    x1 = 1 * radius
    y1 = 0
    seg = []
    for i in range(sides):
        theta = i * 2 * PI / sides
        x2 = cos(theta) * radius
        y2 = sin(theta) * radius
        
        #normal (x1, y1, 0)s
        seg.append([x1, y1, 1])
        seg.append([x1, y1, -1])
        #normal (x2, y2, 0)

        seg.append([x2, y2, -1])
        seg.append([x2, y2, 1])
        x1 = x2
        y1 = y2
    v.append(seg)
    return v
 
def d_cylinder(radius, sides=0):
    v = cylinder(radius)
    for i in range(len(v)-1):
        beginShape()
        for j in range(len(v[i])):
            vertex (v[i][j][0], v[i][j][1], v[i][j][2])
        endShape()

    for j in range(0, len(v[len(v)-1]), 4):
        i = len(v)-1
        beginShape()
        vertex (v[i][j][0], v[i][j][1], v[i][j][2])
        vertex (v[i][j+1][0], v[i][j+1][1], v[i][j+1][2])
        vertex (v[i][j+2][0], v[i][j+2][1], v[i][j+2][2])
        vertex (v[i][j+3][0], v[i][j+3][1], v[i][j+3][2])
        endShape()

# Draw a cylinder with top and bottom param (z-value)
def o_cylinder(radius, top, bottom, sides = 50):
    # first endcap
    beginShape()
    for i in range(sides):
        theta = i * 2 * PI / sides
        x = cos(theta) * radius
        y = sin(theta) * radius
        vertex (x, y, bottom)
    endShape(CLOSE)

    # second endcap
    beginShape()
    for i in range(sides):
        theta = i * 2 * PI / sides
        x = cos(theta) * radius
        y = sin(theta) * radius
        vertex (x, y, top)
    endShape(CLOSE)

    # round main body
    x1 = 1 * radius
    y1 = 0
    for i in range(sides):
        theta = (i + 1) * 2 * PI / sides
        x2 = cos(theta) * radius
        y2 = sin(theta) * radius
        beginShape()
        normal (x1, y1, 0)
        vertex (x1, y1, top)
        vertex (x1, y1, bottom)
        

        normal (x2, y2, 0)
        vertex (x2, y2, bottom)
        vertex (x2, y2, top)
        endShape(CLOSE)
        x1 = x2
        y1 = y2

def nut(radius, top, bottom, sides = 8):
    # first endcap
    beginShape()
    for i in range(sides):
        theta = i * 2 * PI / sides
        x = cos(theta) * radius
        y = sin(theta) * radius
        vertex (x, y, bottom)
    endShape(CLOSE)

    # second endcap
    beginShape()
    for i in range(sides):
        theta = i * 2 * PI / sides
        x = cos(theta) * radius
        y = sin(theta) * radius
        vertex (x, y, top)
    endShape(CLOSE)

    # round main body
    x1 = 1 * radius
    y1 = 0
    for i in range(sides):
        theta = (i + 1) * 2 * PI / sides
        x2 = cos(theta) * radius
        y2 = sin(theta) * radius
        beginShape()
        normal (x1, y1, 0)
        vertex (x1, y1, top)
        vertex (x1, y1, bottom)
        

        normal (x2, y2, 0)
        vertex (x2, y2, bottom)
        vertex (x2, y2, top)
        endShape(CLOSE)
        x1 = x2
        y1 = y2

# Draw a hollow cylinder that doesn't have caps 
def hollow_cylinder(radius, top, bottom, sides = 50):
    # round main body
    x1 = 1 * radius
    y1 = 0
    for i in range(sides):
        theta = (i + 1) * 2 * PI / sides
        x2 = cos(theta) * radius
        y2 = sin(theta) * radius
        beginShape()
        normal (x1, y1, 0)
        vertex (x1, y1, top)
        vertex (x1, y1, bottom)
        

        normal (x2, y2, 0)
        vertex (x2, y2, bottom)
        vertex (x2, y2, top)
        endShape(CLOSE)
        x1 = x2
        y1 = y2
  
# Draw a torus flat in the XY plane
def torus(radius=1.0, tube_radius=0.5, detail_x=16, detail_y=4):
    radius = float(radius)
    tube_radius = float(tube_radius)
    detail_x = int(detail_x)
    detail_y = int(detail_y)

    tube_ratio = (tube_radius / radius)

    def make_torus():
        vertices = []
        normals = []
        for torus_segment in range(detail_x):
            theta = 2 * PI * torus_segment / detail_x
            cos_theta = cos(theta)
            sin_theta = sin(theta)

            segment_vertices = []
            segment_normals = []

            for tube_segment in range(detail_y):
                phi = 2 * PI * tube_segment / detail_y
                cos_phi = cos(phi)
                sin_phi = sin(phi)
                segment_vertices.append(PVector(
                    cos_theta * (radius + cos_phi * tube_radius),
                    sin_theta * (radius + cos_phi * tube_radius),
                    sin_phi * tube_radius,
                ))
                segment_normals.append(PVector(
                    cos_phi * cos_theta,
                    cos_phi * sin_theta,
                    sin_phi,
                ))
            vertices.append(segment_vertices)
            normals.append(segment_normals)
        return vertices, normals

    global GEOMETRY_CACHE
    try:
        GEOMETRY_CACHE
    except NameError:
        GEOMETRY_CACHE = {}
    cache_index = ("torus", radius, tube_radius, detail_x, detail_y)
    if cache_index in GEOMETRY_CACHE:
        vertices, normals = GEOMETRY_CACHE[cache_index]

    else:
        vertices, normals = make_torus()
        GEOMETRY_CACHE[cache_index] = (vertices, normals)

    for i in range(detail_x):
        for j in range(detail_y):
            beginShape()

            normal(normals[i][j].x, normals[i][j].y, normals[i][j].z)
            vertex(vertices[i][j].x, vertices[i][j].y, vertices[i][j].z)
            normal(normals[(i + 1) % detail_x][j].x, normals[(i + 1) % detail_x][j].y, normals[(i + 1) % detail_x][j].z)
            vertex(vertices[(i + 1) % detail_x][j].x, vertices[(i + 1) % detail_x][j].y, vertices[(i + 1) % detail_x][j].z)
            normal(normals[(i + 1) % detail_x][(j + 1) % detail_y].x, normals[(i + 1) % detail_x][(j + 1) % detail_y].y, normals[(i + 1) % detail_x][(j + 1) % detail_y].z)
            vertex(vertices[(i + 1) % detail_x][(j + 1) % detail_y].x, vertices[(i + 1) % detail_x][(j + 1) % detail_y].y, vertices[(i + 1) % detail_x][(j + 1) % detail_y].z)
            normal(normals[i][(j + 1) % detail_y].x, normals[i][(j + 1) % detail_y].y, normals[i][(j + 1) % detail_y].z)
            vertex(vertices[i][(j + 1) % detail_y].x, vertices[i][(j + 1) % detail_y].y, vertices[i][(j + 1) % detail_y].z)

            endShape(CLOSE)
        
def cone(sides=50):
    sides = int(sides)
    vertices = []
    # draw triangles making up the sides of the cone
    for i in range(sides):
        theta = 2.0 * PI * i / sides
        theta_next = 2.0 * PI * (i + 1) / sides
        
        beginShape()
        #normal(cos(theta), 0.6, sin(theta))
        vertex(cos(theta), 1.0, sin(theta))
        #normal(cos(theta_next), 0.6, sin(theta_next))
        vertex(cos(theta_next), 1.0, sin(theta_next))
        #normal(0.0, -1.0, 0.0)
        vertex(0.0, -1.0, 0.0)
        endShape()

    # draw the cap of the cone
    beginShape()
    for i in range(sides):
        theta = 2.0 * PI * i / sides
        vertex(cos(theta), 1.0, sin(theta))
    endShape()



# Cylinder with radius = 1, z range in [-1,1]

def cylinder(radius, sides = 20):
    # first endcap
    v = []
    seg = []
    for i in range(sides):
        v1 = []
        theta = i * 2 * PI / sides
        x = cos(theta) * radius 
        y = sin(theta) * radius
        seg.append([x, y, -1])
    v.append(seg)
    
    #second endcap
    seg = []
    for i in range(sides):
        theta = i * 2 * PI / sides
        x = cos(theta) * radius
        y = sin(theta) * radius
        seg.append([x, y, 1])
    v.append(seg)
    
    # round main body
    x1 = 1 * radius
    y1 = 0
    seg = []
    for i in range(sides):
        theta = i * 2 * PI / sides
        x2 = cos(theta) * radius
        y2 = sin(theta) * radius
        
        #normal (x1, y1, 0)s
        seg.append([x1, y1, 1])
        seg.append([x1, y1, -1])
        #normal (x2, y2, 0)

        seg.append([x2, y2, -1])
        seg.append([x2, y2, 1])
        x1 = x2
        y1 = y2
    v.append(seg)
    return v
 
def d_cylinder(radius, sides=0):
    v = cylinder(radius)
    for i in range(len(v)-1):
        beginShape()
        for j in range(len(v[i])):
            vertex (v[i][j][0], v[i][j][1], v[i][j][2])
        endShape()

    for j in range(0, len(v[len(v)-1]), 4):
        i = len(v)-1
        beginShape()
        vertex (v[i][j][0], v[i][j][1], v[i][j][2])
        vertex (v[i][j+1][0], v[i][j+1][1], v[i][j+1][2])
        vertex (v[i][j+2][0], v[i][j+2][1], v[i][j+2][2])
        vertex (v[i][j+3][0], v[i][j+3][1], v[i][j+3][2])
        endShape()

def o_cylinder(radius, top, bottom, sides = 50):
    # first endcap
    beginShape()
    for i in range(sides):
        theta = i * 2 * PI / sides
        x = cos(theta) * radius
        y = sin(theta) * radius
        vertex (x, y, bottom)
    endShape(CLOSE)

    beginShape()
    for i in range(sides):
        theta = i * 2 * PI / sides
        x = cos(theta) * radius
        y = sin(theta) * radius
        vertex (x + 1, y + 1, bottom)
    endShape(CLOSE)

    # second endcap
    beginShape()
    for i in range(sides):
        theta = i * 2 * PI / sides
        x = cos(theta) * radius
        y = sin(theta) * radius
        vertex (x, y, top)
    endShape(CLOSE)

    beginShape()
    for i in range(sides):
        theta = i * 2 * PI / sides
        x = cos(theta) * radius
        y = sin(theta) * radius
        vertex (x + 1, y + 1, top)
    endShape(CLOSE)
    # round main body
    x1 = 1 * radius
    y1 = 0
    for i in range(sides):
        theta = (i + 1) * 2 * PI / sides
        x2 = cos(theta) * radius
        y2 = sin(theta) * radius
        beginShape()
        normal (x1, y1, 0)
        vertex (x1, y1, top)
        vertex (x1, y1, bottom)
        

        normal (x2, y2, 0)
        vertex (x2, y2, bottom)
        vertex (x2, y2, top)
        endShape(CLOSE)
        x1 = x2
        y1 = y2
    beginShape()
    vertex(x1, 0, top)
    vertex(x1, 0, bottom)
    vertex(-x1, 0, bottom)
    vertex(-x1, 0, top)
    endShape(CLOSE)

def half_cylinder(radius, top, bottom, sides = 50):
    # first endcap
    beginShape()
    for i in range(sides):
        theta = i * 2 * PI / sides
        x = cos(theta) * radius
        y = abs(sin(theta) * radius)
        vertex (x, y, bottom)
    endShape(CLOSE)
    # second endcap
    beginShape()
    for i in range(sides):
        theta = i * 2 * PI / sides
        x = cos(theta) * radius
        y = abs(sin(theta) * radius)
        vertex (x, y, top)
    endShape(CLOSE)
    # round main body
    x1 = 1 * radius
    y1 = 0
    for i in range(sides):
        theta = (i + 1) * 2 * PI / sides
        x2 = cos(theta) * radius
        y2 = abs(sin(theta) * radius)
        beginShape()
        normal (x1, y1, 0)
        vertex (x1, y1, top)
        vertex (x1, y1, bottom)
        

        normal (x2, y2, 0)
        vertex (x2, y2, bottom)
        vertex (x2, y2, top)
        endShape(CLOSE)
        x1 = x2
        y1 = y2

# Draw a torus flat in the XY plane
def torus(radius=1.0, tube_radius=0.5, detail_x=16, detail_y=4):
    radius = float(radius)
    tube_radius = float(tube_radius)
    detail_x = int(detail_x)
    detail_y = int(detail_y)

    tube_ratio = (tube_radius / radius)

    def make_torus():
        vertices = []
        normals = []
        for torus_segment in range(detail_x):
            theta = 2 * PI * torus_segment / detail_x
            cos_theta = cos(theta)
            sin_theta = sin(theta)

            segment_vertices = []
            segment_normals = []

            for tube_segment in range(detail_y):
                phi = 2 * PI * tube_segment / detail_y
                cos_phi = cos(phi)
                sin_phi = sin(phi)
                segment_vertices.append(PVector(
                    cos_theta * (radius + cos_phi * tube_radius),
                    sin_theta * (radius + cos_phi * tube_radius),
                    sin_phi * tube_radius,
                ))
                segment_normals.append(PVector(
                    cos_phi * cos_theta,
                    cos_phi * sin_theta,
                    sin_phi,
                ))
            vertices.append(segment_vertices)
            normals.append(segment_normals)
        return vertices, normals

    global GEOMETRY_CACHE
    try:
        GEOMETRY_CACHE
    except NameError:
        GEOMETRY_CACHE = {}
    cache_index = ("torus", radius, tube_radius, detail_x, detail_y)
    if cache_index in GEOMETRY_CACHE:
        vertices, normals = GEOMETRY_CACHE[cache_index]

    else:
        vertices, normals = make_torus()
        GEOMETRY_CACHE[cache_index] = (vertices, normals)

    for i in range(detail_x):
        for j in range(detail_y):
            beginShape()

            #normal(normals[i][j].x, normals[i][j].y, normals[i][j].z)
            vertex(vertices[i][j].x, vertices[i][j].y, vertices[i][j].z)
            #normal(normals[(i + 1) % detail_x][j].x, normals[(i + 1) % detail_x][j].y, normals[(i + 1) % detail_x][j].z)
            vertex(vertices[(i + 1) % detail_x][j].x, vertices[(i + 1) % detail_x][j].y, vertices[(i + 1) % detail_x][j].z)
            #normal(normals[(i + 1) % detail_x][(j + 1) % detail_y].x, normals[(i + 1) % detail_x][(j + 1) % detail_y].y, normals[(i + 1) % detail_x][(j + 1) % detail_y].z)
            vertex(vertices[(i + 1) % detail_x][(j + 1) % detail_y].x, vertices[(i + 1) % detail_x][(j + 1) % detail_y].y, vertices[(i + 1) % detail_x][(j + 1) % detail_y].z)
            #normal(normals[i][(j + 1) % detail_y].x, normals[i][(j + 1) % detail_y].y, normals[i][(j + 1) % detail_y].z)
            vertex(vertices[i][(j + 1) % detail_y].x, vertices[i][(j + 1) % detail_y].y, vertices[i][(j + 1) % detail_y].z)

            endShape(CLOSE)
        
    

# Cylinder with radius = 1, z range in [-1,1]

def cylinder(sides = 50):
    # first endcap
    beginShape()
    for i in range(sides):
        theta = i * 2 * PI / sides
        x = cos(theta) * radius 
        y = sin(theta) * radius
        vertex (x, y, -1)
    endShape(CLOSE)
    
    #second endcap
    beginShape()
    for i in range(sides):
        theta = i * 2 * PI / sides
        x = cos(theta) * radius
        y = sin(theta) * radius
        vertex (x, y, 1)
    endShape(CLOSE)
    
    # round main body
    x1 = 1 * radius
    y1 = 0
    for i in range(sides):
        theta = i * 2 * PI / sides
        x2 = cos(theta) * radius
        y2 = sin(theta) * radius
        beginShape()
        #normal (x1, y1, 0)
        vertex (x1, y1, 1)

        vertex (x1, y1, -1)
        #normal (x2, y2, 0)

        vertex (x2, y2, -1)
        vertex (x2, y2, 1)
        endShape(CLOSE)
        x1 = x2
        y1 = y2
 

# Draw a torus flat in the XY plane
def torus(radius=1.0, tube_radius=0.5, detail_x=16, detail_y=4):
    radius = float(radius)
    tube_radius = float(tube_radius)
    detail_x = int(detail_x)
    detail_y = int(detail_y)

    tube_ratio = (tube_radius / radius)

    def make_torus():
        vertices = []
        normals = []
        for torus_segment in range(detail_x):
            theta = 2 * PI * torus_segment / detail_x
            cos_theta = cos(theta)
            sin_theta = sin(theta)

            segment_vertices = []
            segment_normals = []

            for tube_segment in range(detail_y):
                phi = 2 * PI * tube_segment / detail_y
                cos_phi = cos(phi)
                sin_phi = sin(phi)
                segment_vertices.append(PVector(
                    cos_theta * (radius + cos_phi * tube_radius),
                    sin_theta * (radius + cos_phi * tube_radius),
                    sin_phi * tube_radius,
                ))
                segment_normals.append(PVector(
                    cos_phi * cos_theta,
                    cos_phi * sin_theta,
                    sin_phi,
                ))
            vertices.append(segment_vertices)
            normals.append(segment_normals)
        return vertices, normals

    global GEOMETRY_CACHE
    try:
        GEOMETRY_CACHE
    except NameError:
        GEOMETRY_CACHE = {}
    cache_index = ("torus", radius, tube_radius, detail_x, detail_y)
    if cache_index in GEOMETRY_CACHE:
        vertices, normals = GEOMETRY_CACHE[cache_index]

    else:
        vertices, normals = make_torus()
        GEOMETRY_CACHE[cache_index] = (vertices, normals)

    for i in range(detail_x):
        for j in range(detail_y):
            beginShape()

            #normal(normals[i][j].x, normals[i][j].y, normals[i][j].z)
            vertex(vertices[i][j].x, vertices[i][j].y, vertices[i][j].z)
            #normal(normals[(i + 1) % detail_x][j].x, normals[(i + 1) % detail_x][j].y, normals[(i + 1) % detail_x][j].z)
            vertex(vertices[(i + 1) % detail_x][j].x, vertices[(i + 1) % detail_x][j].y, vertices[(i + 1) % detail_x][j].z)
            #normal(normals[(i + 1) % detail_x][(j + 1) % detail_y].x, normals[(i + 1) % detail_x][(j + 1) % detail_y].y, normals[(i + 1) % detail_x][(j + 1) % detail_y].z)
            vertex(vertices[(i + 1) % detail_x][(j + 1) % detail_y].x, vertices[(i + 1) % detail_x][(j + 1) % detail_y].y, vertices[(i + 1) % detail_x][(j + 1) % detail_y].z)
            #normal(normals[i][(j + 1) % detail_y].x, normals[i][(j + 1) % detail_y].y, normals[i][(j + 1) % detail_y].z)
            vertex(vertices[i][(j + 1) % detail_y].x, vertices[i][(j + 1) % detail_y].y, vertices[i][(j + 1) % detail_y].z)

            endShape(CLOSE)
        
    

mode=Python
mode.id=jycessing.mode.PythonMode

from shapes import *

# Draw Engine Cylinder
def eng_cylinder1(radius, time, sides=50):
	top, bottom = 1, -1.5
	o_cylinder(radius, top, bottom)
	o_cylinder(radius * 0.9, top + 0.15, top)
	o_cylinder(radius * 0.75, top + 0.5, top + 0.15)

	translate(0,0, 0.1 + sin(time * 2.4)*0.5)
	o_cylinder(radius * 0.6, top + 2.5, 0.25)

	#translate(0,0, -0.5 + sin(time * 2)*0.4)
	o_cylinder(radius * 0.75, top + 2.85, top + 2.5)
	#o_cylinder(radius * 0.9, top + 3, top + 2.85)
	# o_cylinder(radius * 0.35, top + 4, top + 2.5)
	o_cylinder(radius * 0.9, top + 4.5, top + 2.85)
	o_cylinder(radius * 0.8, top + 4.6, top + 4.5)
	
	last_z = top + 4.6
	#bearing(radius, 0, 0, last_z, 0.2)
	return 0, 0, last_z

# Draw Two Bearing
# Need to translate the last object location
# return Left-edge, Right-edge 
def bearing(radius):
	pushMatrix()
	# New bearing z-value
	c_z = 0.3
	rotateY(radians(90))
	rotateZ(radians(90))
	
	nut_h = 0.45
	# (-0.1) (-c_z) (+0.05) --- 0 --- (-0.05) (+c_z) (+0.1)
	#fill(110, 110, 110)
	#nut(radius * 0.4, (c_z*1.7) + nut_h, (c_z*1.7) + 0.15)
	o_cylinder(radius * 0.6, (c_z*1.7) + 0.15, (c_z*1.7) + 0.1)
	o_cylinder(radius * 0.7, (c_z*1.7) + 0.1, c_z + 0.05)
	o_cylinder(radius * 0.6, c_z + 0.05, c_z)

	# Center 
	o_cylinder(radius * 0.5, c_z*2.9, -c_z*2.9)

	o_cylinder(radius * 0.6, -c_z, -c_z - 0.05)
	o_cylinder(radius * 0.7, -c_z - 0.05, -(c_z*1.7) - 0.1)
	o_cylinder(radius * 0.6, -(c_z*1.7) - 0.1, -(c_z*1.7) - 0.15)
	
	fill(110, 110, 110)
	nut(radius * 0.4, (c_z*1.7) + nut_h, (c_z*1.7) + 0.15)
	nut(radius * 0.4, -(c_z*1.7) - 0.15,  -(c_z*1.7) - nut_h)
	
	popMatrix()
	return  -(c_z*1.7) - nut_h,(c_z*1.7) + nut_h

# Draw armStructure
# return x, y, z_top, z_bottom
def armStructure(radius, x, y, z, zPlus, time):
	pushMatrix()
	fill (200, 200, 200)
	dis = 0.4
	#translate(x, y, z + dis + zPlus)
	#rotateX(radians(-60))
	# rotateX(abs(sin(radians(30)*time)))
	c_z = 0.6
	m_size = 7
	o_cylinder(radius * 0.3, c_z*1.15, 0)
	o_cylinder(radius * 0.5, c_z*1.3, c_z*1.15)
	o_cylinder(radius * 0.55, c_z*m_size, c_z*1.3)
	o_cylinder(radius * 0.5, c_z*(m_size+0.15), c_z*m_size)
	o_cylinder(radius * 0.3, c_z*(m_size+1.15), c_z*(m_size+0.15))

	translate(0, radius * 1, c_z * 5)
	#o_cylinder(radius * 0.8, c_z*5, c_z*2)
	popMatrix()

	return x, y, c_z*1.15, c_z*(m_size+1.15)

# Plane's Turbine
def turbine(radius, l):
	# Support line (Cyan)
	def support_line(x,y,z, l_w, l_len, r_angle):
		r_angle = radians(r_angle)
		x, y, z, l_w = float(x), float(y), float(z), float(l_w)
		
		fill(0,255,255)
		rotateY(-r_angle)
		translate(x, y, z)
		box(l_len, l_w, l_w)
		translate(-x, -y, -z)
		rotateY(r_angle)

	pushMatrix()
	translate(0,0,0.1)
	#fill(127,255,212)
	fill(0,255,255)
	torus(radius=1.3, tube_radius=0.1, detail_x=20, detail_y=20)
	# c_start, c_end = 0.1, 1.5
	# hollow_cylinder(1.3, c_end, c_start)
	
	# First shallow cylinder
	translate(0,0,0.3)
	fill(200,200,200)
	torus(radius=1.5, tube_radius=0.3, detail_x=20, detail_y=20)
	
	c_start, c_end = 0.1, 1.2
	hollow_cylinder(1.76, c_end, c_start)
	# #Support line (Cyan)
	# rotateZ(radians(30))
	# support_line(0, 0, -.9, 0.15, 1.7, 50)
	# rotateZ(radians(-30))

	# rotateZ(radians(-30))
	# support_line(0, 0, -.9, 0.15, 1.7, 50)
	# rotateZ(radians(30))

	# rotateZ(radians(-(30+180)))
	# support_line(0, 0, -.9, 0.15, 1.7, 50)
	# rotateZ(radians((30+180)))

	# rotateZ(radians((30+180)))
	# support_line(0, 0, -.9, 0.15, 1.7, 50)
	# rotateZ(radians(-(30+180)))

	rotateZ(radians(0))
	support_line(0, 0, -.9, 0.15, 1.7, 50)
	rotateZ(radians(0))

	rotateZ(radians(180))
	support_line(0, 0, -.9, 0.15, 1.7, 50)
	rotateZ(radians(-180))
	popMatrix()

	# Middle 
	pushMatrix()
	translate(0,0,c_end)
	c_start, c_end = 0, 7
	# CYAN
	fill(0,255,255)
	torus(radius=1.85, tube_radius=0.1, detail_x=20, detail_y=20)
	
	# Middle shallow cylinder
	fill(200, 200, 200)
	hollow_cylinder(1.9, c_end, c_start)

	# Inside of Engine 
	fill(200, 200, 200)
	shear_angle = radians(55)
	rotateX(radians(90))
	rotateZ(radians(62))
	shearX(shear_angle)
	sphere(1.1)
	popMatrix()

	pushMatrix()
	translate(0,0, c_end)
	fill(200, 200, 200)
	shear_angle = radians(55)
	rotateX(radians(90))
	rotateZ(radians(62))
	shearX(shear_angle)
	sphere(1.7)
	popMatrix()

	pushMatrix()
	translate(0,0, c_end)
	translate(0,0, 0.2)
	#fill(127,255,212)
	fill(0,255,255)
	torus(radius=2.03, tube_radius=0.1, detail_x=20, detail_y=20)

	translate(0,0, 0.2)
	translate(0,0, 0.74)
	fill(0,255,255)
	torus(radius=1.85, tube_radius=0.12, detail_x=20, detail_y=20)
	popMatrix()

	max_r = 1.9 * 2
	return max_r, 0, 0

# TODO: Need to animate 
# 		by increasing y-scale of wing proportional to 'time'
# Wing will have light and connecting piece 
def wings(x,y,z, s, time):
	last_x = 0.00

	# Wing piece will have Wing-piece, light, and connecting frame
	def wing_piece(w, h, zH, zPos, dis, time):
		w, h, zH = float(w), float(h), float(zH)
		fill(200,200,200)
		translate(w/2.0, 0, zPos)
		box(w, h, zH)

		# Light line
		fill(0,255,255)
		box(w+0.15, 0.15, zH+0.2)
		
		# Support frame
		fill(180,180,180)
		support_h = zH/1.5
		translate(w/2.0 + dis, 0, -(zH-support_h)/2.0)
		box(dis * 2.0, h/3.0, zH/1.5)
		# Move back to original z-position
		translate(0, 0, (zH-support_h)/2.0)

	pushMatrix()
	x1 = 4.00
	x1_dis = 0.8
	translate(x/2.0 +0.2, 0, 0)
	wing_piece(x1, 1.3, 5.5, 4, x1_dis, time)
	x2 = 5.0
	x2_dis = 0.8
	wing_piece(x2, 1, 4.5, -0.5, x2_dis, time)
	x3 = 8.0
	x3_dis = 1.0
	wing_piece(x3, 0.7, 3, -0.75, x3_dis, time)

	# translate(0.8,0,0)
	# rotateX(radians(90))
	# rotateZ(radians(25))
	# shearY(radians(60))
	# #rotateY(radians(30))
	# sphere(1)
	# shearY(radians(-60))
	# rotateZ(radians(-25))
	# rotateX(radians(-90))
	popMatrix()
	last_x = x/2.0 + 0.2 + x1 + x2 + x3 + x1_dis + x2_dis + x3_dis * 2
	return last_x, 0, 0

# Create Wing-edge at the end of Wings
def wing_edge(x,y,z):
	pushMatrix()
	translate(x,y,z)
	fill(200,200,200)

	# Add light on each cylinder
	def antenna_light(radius, thickness, z):
		translate(0,0,z)
		fill(0,255,255)
		torus(radius=radius, tube_radius=thickness, detail_x=20, detail_y=20)
		translate(0,0,-z)

	# Basic shape of Antenna 
	def antenna(radius):
		top, bottom = 14.5, -3.5
		o_cylinder(radius, top, bottom)
		top1, bottom1 = 5, -0.5
		o_cylinder(radius * 1.6, top1, bottom1)
		top2, bottom2 = 15, 14.5
		o_cylinder(radius * 1.3, top2, bottom2)

		# Anteena Light
		middle_thick, last_thick = 0.08, 0.06
		antenna_light(radius * 0.9, 0.08, bottom)
		translate(0,0, bottom+0.3)
		torus(radius=radius * 0.9, tube_radius=0.08, detail_x=20, detail_y=20)
		translate(0,0,-(bottom+0.3))
		antenna_light(radius * 1.6, middle_thick, bottom1)
		antenna_light(radius * 1.6, middle_thick, top1)
		antenna_light(radius * 1.3, last_thick, bottom2)
		antenna_light(radius * 1.3, last_thick, top2)

	antenna(0.2)

	popMatrix()

def ship_body(x,y,z, time):
	fill(200,200,200)
	def angled_triangle(x,y,z):
		fill(200,200,200)
		beginShape()
		vertex(x,y,z)
		vertex(-x,y,z)
		vertex(0,-y,z)
		endShape(CLOSE)

		beginShape()
		vertex(x,y,-z)
		vertex(-x,y,-z)
		vertex(0,-y,-z)
		endShape(CLOSE)
		
		fill(0,255,255)
		beginShape()
		vertex(x,y,z)
		vertex(x,y,-z)
		vertex(-x,y,-z)
		vertex(-x,y,z)
		endShape(CLOSE)

		beginShape()
		vertex(-x,y,z)
		vertex(-x,y,-z)
		vertex(0,-y,-z)
		vertex(0,-y,z)
		endShape(CLOSE)

		beginShape()
		vertex(0,-y,z)
		vertex(0,-y,-z)
		vertex(x,y,-z)
		vertex(x,y,z)
		endShape(CLOSE)

	s_angle = radians(45)
	top, bottom = 0, 0.5
	translate(0,0,-5)
	rotateX(radians(90))
	scale(3.5,5,2)
	cone(sides=6)
	rotateX(radians(-90))
	translate(0,0,1)
	# Front light
	fill(0,255,255)
	o_cylinder(1.08, 0.1, 0, sides=6)
	
	# Fire
	fill(0,255,255)
	f_z2, f_z1 = 2.2, 1.2
	o_cylinder(0.6, f_z2, f_z1, sides=6)
	f_z3 = f_z2 + 0.3
	f_z4 = f_z3 + 0.3
	fill(0,255,255)
	o_cylinder(0.5, f_z4, f_z3, sides=6)
	
	f_z5 = f_z4 + 0.5
	f_z6 = f_z5 + 0.1
	fill(0,255,255)
	o_cylinder(0.35, f_z6, f_z5, sides=6)
	# fill(200,200,200)
	# o_cylinder(0.8, 2.7, 2.6, sides=6)

	fill(200,200,200)
	o_cylinder(1, 1.2, 0.1, sides=6)
	fill(0,255,255)
	o_cylinder(1.08, 0.94, 0.84, sides=6)















